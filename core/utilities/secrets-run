#!/bin/bash
# cognitive-core: secrets-run — inject secrets and run a command
# Reads .env.tpl, resolves op:// references, exports as env vars, runs command.
#
# Backend selection (automatic):
#   1. If 'op' CLI is available and authenticated → 1Password
#   2. Otherwise → macOS Keychain (security command)
#
# Usage:
#   secrets-run [--env-file=.env.tpl] -- <command> [args...]
#   secrets-run -- npm run deploy
#   secrets-run --env-file=path/to/.env.tpl -- bash script.sh
#
# The .env.tpl format uses op:// references:
#   CLOUDFLARE_API_TOKEN=op://Development/Cloudflare/api-token
#
# For macOS Keychain, op://Vault/Item/field maps to:
#   Service: "Vault/Item"  Account: "field"
#
# To store a secret in Keychain:
#   secrets-store Development/Cloudflare api-token
#
set -euo pipefail

ENV_FILE=".env.tpl"
BACKEND=""

# ---- Parse arguments ----
while [[ $# -gt 0 ]]; do
    case "$1" in
        --env-file=*) ENV_FILE="${1#--env-file=}"; shift ;;
        --env-file)   ENV_FILE="$2"; shift 2 ;;
        --backend=*)  BACKEND="${1#--backend=}"; shift ;;
        --)           shift; break ;;
        *)            break ;;
    esac
done

if [[ $# -eq 0 ]]; then
    echo "Usage: secrets-run [--env-file=.env.tpl] -- <command> [args...]" >&2
    exit 1
fi

if [[ ! -f "$ENV_FILE" ]]; then
    echo "Error: env file not found: $ENV_FILE" >&2
    exit 1
fi

# ---- Detect backend ----
detect_backend() {
    if [[ -n "$BACKEND" ]]; then
        echo "$BACKEND"
        return
    fi

    # Prefer 1Password if available and authenticated
    if command -v op &>/dev/null; then
        if op whoami &>/dev/null 2>&1; then
            echo "1password"
            return
        fi
    fi

    # Fall back to macOS Keychain
    if command -v security &>/dev/null; then
        echo "keychain"
        return
    fi

    echo "none"
}

BACKEND=$(detect_backend)

# ---- Resolve a single op:// reference ----
resolve_secret() {
    local ref="$1"

    # Parse op://Vault/Item/field
    local path="${ref#op://}"
    local vault_item="${path%/*}"
    local field="${path##*/}"

    case "$BACKEND" in
        1password)
            op read "$ref" 2>/dev/null
            ;;
        keychain)
            security find-generic-password -s "$vault_item" -a "$field" -w 2>/dev/null
            ;;
        *)
            echo "Error: no secrets backend available (install op CLI or use macOS)" >&2
            return 1
            ;;
    esac
}

# ---- Read .env.tpl and export secrets ----
resolve_count=0
fail_count=0

while IFS= read -r line; do
    # Skip comments and blank lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// /}" ]] && continue

    # Parse KEY=op://...
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=op://(.+)$ ]]; then
        key="${BASH_REMATCH[1]}"
        ref="op://${BASH_REMATCH[2]}"

        value=$(resolve_secret "$ref") || true
        if [[ -n "$value" ]]; then
            export "$key=$value"
            resolve_count=$((resolve_count + 1))
        else
            echo "Warning: failed to resolve $key ($ref)" >&2
            fail_count=$((fail_count + 1))
        fi
    fi
done < "$ENV_FILE"

if [[ $fail_count -gt 0 ]]; then
    echo "secrets-run: resolved $resolve_count/$((resolve_count + fail_count)) secrets via $BACKEND" >&2
    echo "Hint: use 'secrets-store' to add missing secrets to Keychain" >&2
fi

# ---- Run the command ----
exec "$@"
